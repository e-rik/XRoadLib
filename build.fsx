#r "paket:
nuget Fake.Api.GitHub
nuget Fake.Core.Environment
nuget Fake.Core.ReleaseNotes
nuget Fake.Core.Target
nuget Fake.Documentation.DocFx
nuget Fake.DotNet.Cli
nuget Fake.DotNet.Paket
nuget Fake.Tools.Git
nuget Octokit //"

// http https://github.com/dotnet/docfx/releases/download/v2.45/docfx.zip 

#load "./.fake/build.fsx/intellisense.fsx"

open Fake.Api
open Fake.Core
open Fake.Core.TargetOperators
open Fake.Documentation
open Fake.DotNet
open Fake.IO
open Fake.IO.FileSystemOperators
open Fake.IO.Globbing.Operators
open Fake.Tools
open System.IO

// Git configuration (used for publishing documentation in gh-pages branch)
// The profile where the project is posted
let gitOwner = "janno-p"
let gitHome = "https://github.com/" + gitOwner

// The name of the project on GitHub
let gitName = "XRoadLib"

// The url for the raw files hosted
let gitRaw = Environment.environVarOrDefault "gitRaw" ("https://raw.github.com/" + gitOwner)

// Strong name key file for assembly signing
let keyFile = "src" </> "XRoadLib.snk"

// Read additional information from the release notes document
let release = ReleaseNotes.load "RELEASE_NOTES.md"

// Projects which will be included in release
let productProjects =
    !! "src/*/*.csproj"

let docFxToolPath = __SOURCE_DIRECTORY__ </> "paket-files" </> "build" </> "github.com" </> "docfx.exe"
let tempDocsDir = __SOURCE_DIRECTORY__ </> "temp" </> "gh-pages"

// --------------------------------------------------------------------------------------
// Remove files generated by previous build

Target.create "Clean" (fun _ ->
    !! "src/*/bin"
    ++ "test/*/bin"
    ++ "bin"
    ++ "temp"
    |> Shell.cleanDirs
)

// --------------------------------------------------------------------------------------
// Builds product assemblies in release mode

Target.create "BuildRelease" (fun _ ->
    productProjects
    |> Seq.iter (fun proj ->
        DotNet.restore id proj
        DotNet.build
            (fun p ->
                { p with
                    Common = { p.Common with CustomParams = Some(sprintf "/p:Version=%s" release.NugetVersion) }
                    Configuration = DotNet.BuildConfiguration.Release })
            proj
    )
)

// --------------------------------------------------------------------------------------
// Copies binaries from default location to expected bin folder
// But keeps a subdirectory structure for each project in the
// src folder to support multiple project outputs

Target.create "CopyBinaries" (fun _ ->
    productProjects
    |> Seq.map (fun f -> Path.GetDirectoryName(f))
    |> Seq.allPairs ["net452"; "net461"]
    |> Seq.filter (fun (fw, d) -> Directory.Exists(d </> "bin" </> "Release" </> fw))
    |> Seq.map (fun (fw, d) -> (d </> "bin" </> "Release" </> fw, "bin" </> DirectoryInfo(d).Name))
    |> Seq.iter (fun (fromDir, toDir) -> Shell.copyDir toDir fromDir (fun _ -> true))
)

// --------------------------------------------------------------------------------------
// Run tests for all target framework versions

Target.create "RunTests" (fun _ ->
    let testsPath = "test" </> "XRoadLib.Tests"
    let projectPath = testsPath </> "XRoadLib.Tests.csproj"

    DotNet.restore id projectPath

    ["net452"; "netcoreapp2.1"]
    |> List.iter
        (fun fw ->
            DotNet.build (fun p -> { p with Configuration = DotNet.BuildConfiguration.Debug; Framework = Some(fw) }) projectPath
            DotNet.exec id "xunit" (testsPath </> "bin" </> "Debug" </> fw </> "XRoadLib.Tests.dll") |> ignore
        )
)

// --------------------------------------------------------------------------------------
// Build a NuGet package

Target.create "NuGet" (fun _ ->
    productProjects
    |> Seq.iter (fun proj ->
        DotNet.pack
            (fun p ->
                { p with
                    Common = { p.Common with CustomParams = Some(sprintf "/p:Version=%s" release.NugetVersion) }
                    OutputPath = Some(__SOURCE_DIRECTORY__ </> "bin")
                    Configuration = DotNet.BuildConfiguration.Release
                    VersionSuffix = release.SemVer.PreRelease |> Option.map (fun v -> v.Origin) })
            proj
    )
)

Target.create "PublishNuget" (fun _ ->
    let apiKey = Environment.environVarOrFail "NUGET_KEY"
    Paket.push
        (fun p ->
            { p with
                WorkingDir = "bin"
                ApiKey = apiKey })
)

// --------------------------------------------------------------------------------------
// Generate documentation

Target.create "GenerateHelp" (fun _ ->
    Shell.rm "docs/articles/release-notes.md"
    Shell.copyFile "docs/articles/" "RELEASE_NOTES.md"
    Shell.rename "docs/articles/release-notes.md" "docs/articles/RELEASE_NOTES.md"

    Shell.rm "docs/articles/license.md"
    Shell.copyFile "docs/articles/" "LICENSE.md"
    Shell.rename "docs/articles/license.md" "docs/articles/LICENSE.md"
)

Target.create "CleanDocs" (fun _ ->
    Shell.cleanDirs [ tempDocsDir ]
)

Target.create "Serve" (fun _ ->
    DocFx.exec
        (fun p -> { p with DocFxPath = docFxToolPath })
        "serve"
        tempDocsDir
)

Target.description "Generate the documentation"
Target.create "GenerateDocs" (fun _ ->
    DocFx.exec
        (fun p -> { p with DocFxPath = docFxToolPath })
        (__SOURCE_DIRECTORY__ </> "docs" </> "docfx.json")
        ""
)

Target.create "ReleaseDocs" (fun _ ->
    Shell.cleanDirs [ tempDocsDir ]
    Git.Repository.cloneSingleBranch "" (sprintf "%s/%s.git" gitHome gitName) "gh-pages" tempDocsDir
    DocFx.exec
        (fun p -> { p with DocFxPath = docFxToolPath })
        (__SOURCE_DIRECTORY__ </> "docs" </> "docfx.json")
        ""
    Git.Staging.stageAll tempDocsDir
    Git.Commit.exec tempDocsDir (sprintf "Update generated documentation for version %s" release.NugetVersion)
    Git.Branches.push tempDocsDir
)

// --------------------------------------------------------------------------------------
// Release Scripts

Target.create "CheckKeyFile" (fun _ ->
    if not (Shell.testFile keyFile) then
        failwithf "Assembly strong name key file `%s` is not present." keyFile
)

Target.create "Release" (fun _ ->
    let user = Environment.environVarOrFail "github-user"
    let pw = Environment.environVarOrFail "github-pw"

    let remote =
        Git.CommandHelper.getGitResult "" "remote -v"
        |> Seq.filter (fun (s: string) -> s.EndsWith("(push)"))
        |> Seq.tryFind (fun (s: string) -> s.Contains(gitOwner + "/" + gitName))
        |> function None -> gitHome + "/" + gitName | Some (s: string) -> s.Split().[0]

    Git.Staging.stageAll ""
    Git.Commit.exec "" (sprintf "Bump version to %s" release.NugetVersion)
    Git.Branches.pushBranch "" remote (Git.Information.getBranchName "")

    Git.Branches.tag "" release.NugetVersion
    Git.Branches.pushTag "" remote release.NugetVersion

    // release on github
    GitHub.createClient user pw
    |> GitHub.draftNewRelease gitOwner gitName release.NugetVersion (release.SemVer.PreRelease <> None) release.Notes
    // |> GitHub.uploadFile "PATH_TO_FILE"
    |> GitHub.publishDraft
    |> Async.RunSynchronously
)

Target.create "BuildPackage" ignore
Target.create "All" ignore

"Clean"
    ==> "RunTests"
    ==> "BuildRelease"
    ==> "CopyBinaries"
    ==> "GenerateDocs"
    ==> "All"
    =?> ("ReleaseDocs", BuildServer.isLocalBuild)

"All"
    ==> "NuGet"
    ==> "BuildPackage"

"CleanDocs"
    ==> "GenerateHelp"
    ==> "GenerateDocs"

"CheckKeyFile"
    ==> "Release"

"ReleaseDocs"
    ==> "Release"

"BuildPackage"
    ==> "PublishNuget"
    ==> "Release"

Target.runOrDefaultWithArguments "All"
